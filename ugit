#!/usr/bin/env bash

# ugit: Undo your last oopsie in Git

# TODO: Add self-updating --update #

set -uo pipefail;

installed() {
    cmd=$(command -v "${1}")

    [[ -n "${cmd}" ]] && [[ -f "${cmd}" ]]
    return ${?}
}

die() {
    >&2 echo "Fatal: ${@}"
    exit 1
}

[[ "${BASH_VERSINFO[0]}" -lt 3 ]] && die "Bash >=3 required"

deps=(fzf git awk xargs cut nl)
for dep in "${deps[@]}"; do
    installed "${dep}" || die "Missing dependency: '${dep}'"
done

printf "%s\n%s" "$(tput bold)Undo your last oopsie in Git üôàÔ∏è$(tput sgr0)" "Contact üì¨Ô∏è: varshneybhupesh@gmail.com for assistance"

display_menu() {
    printf "%s\n" "Undo [git commit]"
    printf "%s\n" "Undo [git push]"
    printf "%s\n" "Undo [git add]"
    printf "%s\n" "Undo [git pull]"
    printf "%s\n" "Undo/Change [git commit message]"
    printf "%s\n" "Undo local branch delete [git branch -d]"
    printf "%s\n" "Undo [git reset]"
    printf "%s\n" "Undo a Merge with Conflicts"
    printf "%s\n" "Undo an Unpushed Merge Commit"
    printf "%s\n" "Undo a Pushed Merge Commit"
    printf "%s\n" "Undo [git stash pop/drop/clear]"
    printf "%s\n" "Undo [git stash apply]"
    printf "%s\n" "Undo [git tag -d] tag delete"
    printf "%s\n" "Undo [git rebase]"
}

option=$(display_menu | nl -n ln | fzf --header="Don't worry we all mess up sometimes" --height 30% --reverse --pointer='·êÖ' --cycle | awk '{print $1}')

undo_git_commit() {
    # TODO: ask which commit to undo?
    git reset HEAD~
    # undo last commit (don't unstage everything)
    # git reset --soft HEAD^
}

do_git_reset() {
    # FROM: https://stackoverflow.com/questions/1223354/undo-git-pull-how-to-bring-repos-to-old-state
    FZF_HEADER=${1:-"Choose last good branch commit"}
    last_good_state=$(git reflog | fzf --ansi --height 20% --reverse --header="$FZF_HEADER" | awk '{print $1}')
    # check if working tree is clean or not
    [[ $(git status --porcelain 2>/dev/null) ]] && read -p "You have uncommited changes, still proceed? [Y/n]: " -n 1 -r USER_INPUT
    USER_INPUT=${USER_INPUT:-Y}
    [[ "$USER_INPUT" == Y ]] && git reset --hard "$last_good_state"
}

undo_git_add() {
    # show prompt to unstage files interactively
    choices=$(git ls-files | fzf --height 10% --reverse --multi --marker='ü¢Ç' --color 'marker:#B8CC52' --header="Choose Files to unstage (TAB to select)")
    git restore --staged $choices
}

change_commit_message() {
    echo -e "Enter New Commit Message (Ctrl+d to save):"
    msg=$(</dev/stdin)
    echo
    [[ "$msg" ]] && git commit --amend -m "$msg" || echo "bruh enter something!!"
}

undo_git_push() {
    commit_hash=$(git log --oneline | fzf --ansi --height 10% --reverse --multi --header="Choose Commit hash to revert/undo" | awk '{print $1}')
    git revert "$commit_hash"
    echo "Make sure to run 'git push' now"
}

undo_branch_delete() {
    # undo local branch delete
    last_branch_commit=$(git reflog | fzf --ansi --height 20% --reverse --multi --header="Choose last good branch commit" | awk '{print $1}')
    # echo "$last_branch_commit"
    read -p "Enter Branch Name: " branch_name
    if git checkout -b "$branch_name" "$last_branch_commit"; then
        printf "%s\n" "Branch $branch_name successfully recovered"
    fi
}

undo_git_reset() {
    LAST_GOOD_STATE=$(git reflog | fzf --ansi --height 20% --reverse --multi --header="Choose last known good commit" | awk '{print $1}')
    git reset "$LAST_GOOD_STATE"
}

# WIP (untested)
undo_git_merge() {
    if [[ "$1" == "conflicts" ]]; then
        git merge --abort
    elif [[ "$1" == "unpushed" ]]; then
        # FROM: https://stackoverflow.com/questions/1223354/undo-git-pull-how-to-bring-repos-to-old-state
        last_good_state=$(git reflog | fzf --ansi --height 20% --reverse --header="Choose last good branch commit" | awk '{print $1}')
        # check if working tree is clean or not
        [[ $(git status --porcelain 2>/dev/null) ]] && read -p "You have uncommited changes, still proceed? [Y/n]: " -n 1 -r USER_INPUT
        USER_INPUT=${USER_INPUT:-Y}
        [[ "$USER_INPUT" == Y ]] && git reset --hard "$last_good_state"
    else
        default_branch=$(git remote show origin | awk '/HEAD/ {print $3}')
        echo -e "Switching to default branch $default_branch"
        git checkout "$default_branch"
        commit_hash=$(git log --oneline | fzf --ansi --height 10% --reverse --header="Choose appropriate hash of the merge commit" | awk '{print $1}')
        git revert -m 1 "$commit_hash"
    fi
}

recover_lost_stash() {
    LOST_STASH=$(git fsck --no-progress --unreachable | grep commit | cut -d ' ' -f3 | xargs git log --oneline --merges --no-walk | fzf --ansi --height 20% --reverse --header="Choose commit associated with stash" | awk '{print $1}')
    read -p "Enter Stash Message/Comment: " -r STASH_MSG
    if git update-ref refs/stash "$LOST_STASH" --create-reflog -m "$STASH_MSG"; then
        printf "%s\n" "Stash Successfully Recovered"
        git stash list | grep "$STASH_MSG"
    fi
}

undo_git_stash_apply() {
    # check if diff coloring is set to auto in git config if not the reverse apply command will fail
    is_diff_color=$(git config --get color.diff | tr -d '\n')
    if [[ "$is_diff_color" == "auto" ]]; then
        if git stash show -p | git apply --reverse; then
            printf "%s\n" "Done üëçÔ∏è"
        fi
    else
        printf "%s\n" "Please change diff color to auto in .gitconfig & run ugit again"
        printf "%s\n" "Or use the following command [git config --global color.diff \"auto\"]"
    fi
}

recover_deleted_tag() {
    # only works for annotated tags? :(

    # git fsck --unreachable | grep tag
    # to see changes git show <COMMIT_HASH>
    # git update-ref refs/tags/<tag-name> <COMMIT_HASH>
    read -p "Enter lost Tag name (e.g v1.2): " -r TAG_NAME
    COMMIT_HASH=$(git fsck --no-progress --unreachable --tags | awk '/tagged/ {print $6}')
    [[ -z "$COMMIT_HASH" ]] && printf "%s\n" "Unable to find any deleted tags :(" && exit 1
    OBJECT_TYPE=$(git cat-file -t "$COMMIT_HASH")
    if [[ "$OBJECT_TYPE" == "tag" ]] ; then
        printf "%s\n" "Found Deleted tag"
    fi
    DELETED_TAG=$(git cat-file -p "$COMMIT_HASH" | awk '/tag / { print$2 }')
    if [[ "$DELETED_TAG" != "$TAG_NAME" ]]; then
        printf "%s" "Input tag name $TAG_NAME doesn't match with previously deleted tag $DELETED_TAG"
    elif git update-ref refs/tags/"$TAG_NAME" --create-reflog "$COMMIT_HASH"; then
        printf "%s\n" "Tag $TAG_NAME Successfully Recovered üëçÔ∏è"
        git cat-file tag "$DELETED_TAG"
    fi
}

case $option in
    1) undo_git_commit;;
    2) undo_git_push;;
    3) undo_git_add;;
    4) undo_git_merge "unpushed";;
    5) change_commit_message;;
    6) undo_branch_delete;;
    7) undo_git_reset;;
    8) undo_git_merge "conflicts";;
    9) do_git_reset;;
    10) undo_git_merge "pushed";;
    11) recover_lost_stash;;
    12) undo_git_stash_apply;;
    13) recover_deleted_tag;;
    14) do_git_reset "Choose commit just before rebase started";;
esac
